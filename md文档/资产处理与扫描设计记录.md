# 资产处理与“安检门”设计记录（2025-11）

> 本文是一次对话驱动的设计/实现记录，用于说明当前**安检门**在后端的真实语义，以及标签/人脸等 AI 模块在初始化与媒体路径变更时如何被统一触发。

## 一、术语统一：什么是“安检门”

在本项目中，**安检门**不再指某个单独的按钮或接口，而是一个**后台流水线的总称**，包括：

1. **枚举文件并入库（入库扫描）**
   - 通过 `MediaSource` + 入库扫描任务，将文件写入 `Media` 等表。
2. **资产处理模块**
   - 缩略图生成、元数据抽取等（`AssetPipeline`，`THUMBNAIL`/`METADATA` 等 `ArtifactType`）。
3. **AI 标注/审查模块**
   - 文本向量：CLIP / SigLIP（`ClipEmbedding`）。
   - 标签：WD tagger（`MediaTag`）。
   - NSFW：后续在 AI 模块中统一扩展。
   - 人脸：检测 + embedding + 聚类（`FaceEmbedding`、`FaceCluster`）。

对用户而言，仅存在两类触发入口：

1. 初始化/切换媒体库：`POST /setup/media-root`
2. 设置里管理媒体路径（新增/恢复来源）：`POST /setup/source`（前端通过此路由管理 `MediaSource`）

**没有一个“开始安检门”按钮**；所有安检门行为都是上述两个入口触发的后台流水线。

## 二、初始化流程：对“所有媒体路径”做全库处理（触发安检门）

入口：`app/api/setup_routes.py:set_media_root`（`POST /setup/media-root`）

主要步骤：

1. 校验/保存媒体根路径 `MEDIA_ROOT`。
2. **首批导入**（快速体验）：
   - 调用 `scan_source_once(..., limit=50)` 导入少量媒体，确保前端能立刻看到内容。
3. 注册自动扫描/监控服务（入库扫描入口之一）：
   - `ensure_auto_scan_service(app)` + `register_path` + `trigger_path`。
4. 启动后台导入与流水线暖机（通过 `BackgroundTasks`）：
   - 若该根路径已对应某个 `MediaSource`：
     - `start_scan_job(src.id, src.root_path, background)`  
       → 持续导入媒体，写入 `Media`。
     - `warmup_assets_for_source(src.id)`  
       → 缩略图、元数据等资产任务预热（资产处理模块）。
   - CLIP 向量暖机：
     - `warmup_missing_clip_embeddings()`  
       → 针对 **所有“活动媒体”**，为缺少向量的媒体补齐 embedding。
   - 标签暖机：
     - `warmup_rebuild_tags_for_active_media()`（见下文）。
   - 人脸暖机：
     - `warmup_rebuild_face_clusters()`（见下文，多路径聚类）。

因此，从初始化入口看，**安检门** = **全库导入 + 资产预热 + CLIP + 标签 + 人脸**，并且会自动持续处理，不依赖手工操作。

## 三、设置里新增媒体路径：只对“新增来源”导入，但 AI 模块视全库为总仓库（触发安检门）

入口：`app/api/sources_routes.py:create_media_source`（`POST /setup/source`）

- 注释已更新：
  ```python
  # 控制是否在创建来源后立即启动“后台导入 + 资产/AI 流水线”。
  # 前端不需要显式提供该字段，默认 True 仅为兼容早期脚本调用。
  scan_now = True if payload.scan is None else bool(payload.scan)
  ```

对于 `SourceType.LOCAL` / `SourceType.SMB`（安检门入口之一）：

1. 校验路径 / 重叠检测 / 幂等处理：
   - 若相同 `rootPath` / `root_url` 已存在，返回 200 并跳过重复导入。
2. 新建来源成功后，若 `scan_now = True`（前端不传即为 True）：
   - `_bootstrap_source_scan(src.root_path)`  
     → 首批导入部分媒体（便于前端快速看到内容），后续由自动扫描服务增量导入。
   - `_ensure_background_scan(request, src.root_path)`  
     → 注册/触发自动扫描服务。
   - 通过 `BackgroundTasks` 启动后台流程：
     - `start_scan_job(src.id, src.root_path, background)`  
       → 针对此来源的后台导入任务。
     - `warmup_assets_for_source(src.id)`  
       → 为该来源预热缩略图/元数据（资产处理模块）。
     - `warmup_missing_clip_embeddings()`  
       → 在所有“活动媒体”范围内补齐向量。
     - `warmup_rebuild_tags_for_active_media()`  
       → 对所有活动媒体重建标签（WD）。
     - `warmup_rebuild_face_clusters()`  
       → 对所有本地媒体路径统一做人脸聚类（总仓库语义）。

**关键点**：  
- 对“文件导入层面”，新增来源只导入该来源下的文件；  
- 对 AI 模块（向量/标签/人脸），都是基于“当前所有活动媒体路径”视为一个总仓库来处理。

## 四、标签暖机：对当前“活动媒体”统一 rebuild_tags

新模块：`app/services/tag_warmup.py`

- `warmup_rebuild_tags_for_active_media(limit: Optional[int] = None) -> Optional[dict]`
  - 构造“活动媒体”查询：
    - 若存在 `MediaSource` 记录：
      - 包含：
        - `Media.source_id IS NULL` 的历史媒体（兼容 legacy）。
        - 绑定到 `status = NULL or 'active'` 且 `deleted_at IS NULL` 的来源的媒体。
    - 若不存在 `MediaSource` 记录：
      - 所有 `media_type == "image"` 的 `Media` 为活动媒体。
  - 可选 `limit`：按 `Media.id` 升序截断参与本次重建的媒体数量。
  - 收集 `media_ids` 列表后，调用：
    ```python
    wd_tag_service.rebuild_tags(
        db,
        base_path=None,
        media_ids=media_ids,
        batch_size=8,
        limit=None,  # 由查询阶段控制数量
        model_name=None,
        ...
    )
    ```
  - 捕获 `ServiceError`（模型未就绪等）只打日志，不向上抛。

使用场景：
- 初始化媒体根目录时（`/setup/media-root`）
- 新增媒体来源时（`/setup/source`）

目的：
- 让“资产处理进度”视图中，标签覆盖率可以尽快接近 100%，支持前端按标签过滤和搜索。

## 五、人脸暖机：多媒体路径统一聚类为一个总仓库

### 5.1 face_cluster_service 扩展

文件：`app/services/face_cluster_service.py`

在原有 `rebuild_clusters` 基础上，拆出多路径版本：

1. `_collect_faces_for_roots(db, roots: Sequence[Path], face_app) -> (detected, media_count)`
   - 遍历多个根目录：
     - 使用 `_iter_media_files(root)` 枚举图片文件。
     - `_ensure_media_record` 确保对应 `Media` 记录存在。
     - 调用 InsightFace 检测人脸，过滤小尺寸/低置信度人脸。
     - 收集 `_DetectedFace` 列表（embedding + bbox + media_id 等）。

2. `_persist_clusters(db, detected, similarity_threshold) -> (face_count, cluster_count)`
   - 汇总所有 `detected` 的 embedding：
     - 归一化 → HDBSCAN 聚类 → 噪声单独成簇 → 重新编号聚类 ID。
   - 写入：
     - `FaceCluster`：簇信息、代表媒体 ID。
     - `FaceEmbedding`：每张人脸的 embedding、bbox、cluster_id 等。
   - 返回人脸数与簇数。

3. `rebuild_clusters_for_paths(db, base_paths: Sequence[str], similarity_threshold: float)`
   - 将 `base_paths` 中每条路径解析为本地目录（`_resolve_base_path`）。
   - 清空 `FaceEmbedding` / `FaceCluster` 表。
   - 调用 `_collect_faces_for_roots` + `_persist_clusters`：
     - **多个本地媒体路径被视作“同一总仓库”一起聚类**。

4. 原 `rebuild_clusters(db, base_path=...)` 仍保留，用于单路径调试，但暖机流程使用多路径版本。

### 5.2 face_warmup：自动解析“需要聚类的所有本地路径”

新文件：`app/services/face_warmup.py`

- `_resolve_local_scan_roots(session: Session) -> List[str]`
  - 若存在 `MediaSource` 记录：
    - 选出所有 `status = NULL or 'active'` 且 `deleted_at IS NULL` 的来源；
    - 仅保留本地路径（过滤掉 `smb://`）。
  - 若不存在任何 `MediaSource`：
    - 回退到 `MEDIA_ROOT_KEY`（同样忽略 `smb://`）。
  - 去重并保持顺序。

- `warmup_rebuild_face_clusters(base_path: Optional[str] = None, similarity_threshold: float = 0.65)`
  - 通过 `_resolve_local_scan_roots` 拿到所有本地媒体路径；
  - 若列表为空（全为 SMB 等），打印日志并跳过；
  - 调用：
    ```python
    face_cluster_service.rebuild_clusters_for_paths(
        db,
        base_paths=roots,
        similarity_threshold=similarity_threshold,
    )
    ```
  - 日志中打印总 media 数、人脸数、簇数以及参与聚类的路径列表。

使用场景：
- 初始化媒体根目录时（`/setup/media-root`）
- 新增媒体来源时（`/setup/source`）

**满足的需求**：  
> “所有媒体路径，就算有多个，它们也是一个总仓库，需要一起聚类。”

## 六、任务视图与统计：资产处理进度

接口：`GET /tasks/asset-pipeline` → `app/api/task_routes.py:get_asset_pipeline_status`

统计逻辑：

- 只统计“活动媒体”：
  - 若 `MediaSource` 为空：所有 `Media` 为活动媒体。
  - 若存在来源：只统计：
    - `source_id IS NULL` 的 legacy 媒体；
    - 绑定到 active + 未删除来源的媒体。

- key 指标：
  - `total_media`：活动媒体总数。
  - `THUMBNAIL`：asset_artifacts 中 READY 状态数量。
  - `VECTOR`：至少有一条 `ClipEmbedding` 记录的媒体数量。
  - `TAGS`：至少有一条 `MediaTag` 记录的媒体数量。
  - `FACES`：至少有一条 `FaceEmbedding` 记录的媒体数量。

随着初始化/新增来源时的暖机任务完成，前端“资产处理进度”页面应能看到：

- 缩略图：100% 覆盖；
- Web 向量处理（向量）：接近/达到 100%；
- 标签：接近/达到 100%（取决于模型是否可用）；
- 人脸：在所有本地路径完成聚类后，覆盖率反映真实有脸媒体的数量。

## 七、接口与术语清理：下线 /scan/start，去“按钮化”的安检门概念

为避免误导“有一个开始安检门按钮”，本次做了以下收敛：

1. **完全下线 `/scan/start` 接口**：
   - 删除 `app/api/sources_routes.py` 中的 `@router.post("/scan/start")` 路由。
   - 删除 `app/schemas/sources.py` 中的 `ScanStartResponse`。

2. **前端 API 清理**：`webclient/lib/api.ts`
   - 删除：
     - `ScanStartResponse` 接口。
     - `startScan(sourceId: number)` 函数。
   - 保留 `getScanStatus(jobId)`，并标为“当前前端未使用，仅调试/脚本可选调用”：
     ```ts
     // 获取后台导入/索引任务的状态（当前前端未使用，仅调试/脚本可选调用）
     export async function getScanStatus(jobId: string): Promise<ScanStatusResponse | null> { ... }
     ```

3. **文案统一**：
   - `setup_routes.py` 中将“首批入库扫描失败”改为“首批导入失败”，提示改为“后台持续导入/处理中”。
   - `sources_routes.py` 中所有“跳过入库扫描”的注释改为“跳过重复导入/处理”。

## 八、后续可选工作

1. 若不再需要 `/scan/status`，可以进一步：
   - 将入库扫描任务进度完全折叠进 `/tasks/scan-progress` / `/tasks/asset-pipeline`；
   - 或保留 `/scan/status` 仅供 CLI/脚本调试（当前已经不被前端调用）。

2. 视频如何进入现有“图像模型”（WD/CLIP/人脸）管线：
   - **模型本质**：WD 打标、CLIP/SigLIP 向量、人脸检测/聚类都属于“图像模型”，无法直接对整段视频做推理；
   - **MVP 方案（已落地）**：对每个 video 先抽一张代表帧（沿用缩略图逻辑，默认 1s 左右）→ 再把这张帧当作 image 输入，复用既有模型与落库结构：
     - CLIP：对视频“代表帧”生成向量，写入 `clip_embeddings (media_id=video.id)`；
     - WD：对视频“代表帧”生成标签，写入 `media_tags (media_id=video.id)`；
     - 人脸：对视频“代表帧”做人脸检测并参与聚类，写入 `face_embeddings / face_clusters`；
   - **实现入口**：
     - `app/services/model_input_image.py`：统一把 `Media(image/video + 本地/SMB)` 解析成“可读的图像输入路径”（视频/SMB 走缩略图帧，本地图片优先原图）；
     - 任务统计口径中，向量/标签的分母调整为 `image+video`；人脸聚类仅统计本地媒体，并使用 `face_processing_states` 记录“已处理（含 0 face）”，避免任务页出现“永远排队”的误导。
   - **进阶方案（规划）**：若要提升视频标签/检索精度，应在后台做“段级/关键帧”抽取：
     - 镜头检测/定间隔抽帧 → 关键帧级向量/标签/NSFW/人脸 → 聚合成视频级结果；
     - 建议新增 `media_video_segments` / `media_video_keyframes` 表（或等价结构），并在任务视图中展示 segment/keyframe 的处理进度与失败原因。
